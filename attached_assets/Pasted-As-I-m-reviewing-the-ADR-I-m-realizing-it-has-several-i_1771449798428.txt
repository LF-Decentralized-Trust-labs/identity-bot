As I'm reviewing the ADR I'm realizing it has several items that are incorrect. In ADR 002 here is the problem: "The Problem:
The current draft of ADR 002 (specifically Section 4 "Driver Lifecycle Management") creates a false dichotomy between "Development" and "Production."

It suggests that spawning the Python process is only for "Development."

It suggests that connecting to a remote URL is for "Production."

The Goal:
I want to eliminate the concept of "Development Mode" entirely. The code should run the exact same way in development as it does in production."

I did not read adr002 until just now so I would like for you to update it so it's correct. And basically it's not a matter of whether it's development or production but rather replit, Linux, Windows, iOS all of those should spawn python as a child process and the process is killed when go exits. So rather than development versus production it the trigger depends on the environment. For the Linux and windows and that set of operating systems I want it of course to spawn python as a child process and there won't be a need for a URL in there. But that being said that is only if the server is in primary mode. Because in primary mode the server is always on and it is the one that is responsible for running keri functions. But if it is in backup mode or turned off then the child back end process will not be running and therefore the front end needs to be able to access python. Now we could have the front end just use the same environment that the front end uses on mobile but the architecture is simpler if it just uses the python device process or driver process in other words it's more efficient since python can run on a Linux and windows and Etc it's more efficient if it just uses the python-based child process that the go backend uses. So in this case perhaps the best structure could be to have the front end verify if the process is running for the python child and if it is then it's likely already running because the back end already started it but if it's not running because the back end was turned off then the front end can turn on this child process and use it. This means that while on Linux and windows and these types of platforms the front end will not need to use the flutter rust Bridge will it need to use the remote KERI helper. So this keeps the architecture simpler on these platforms. But on mobile that's where it follows the process that is outlined in adr3. Referring to the three-step process. Then for adr3 I think the title needs to be a little bit more clear because it says adaptive architecture three operating modes but is this talking about three keri operating modes? I think it is because the first mode it calls it desktop mode which refers to those Linux and Mac OS and windows where it needs to contact the python carry driver which is the child process. And then it says mobile remote mode where it is iOS or Android with the primary server configured and primary server refers to the identity agent server for the identity agent backend so we have to make sure that we are clear we are talking about each identity has to have an identity agent setup, and an identity agent requires a back end and a front end at minimum. This is already outlined in documentation and the architecture I think even in ADR 001. So on this second mode it says that the primary server is configured and that means all of the keri operations are routed to the remote servers API which is where it uses the child driver so that is accurate. And then the third mode is the mobile Standalone mode where it says the IOS and Android are running an instance of an identity agent where the front end is present and on and active but the back end is not the primary back end identity agent server. Because if there is no primary server URL then that's how it knows it does not have one. And in that case it uses the rust Bridge and then it optionally can use the remote helper as a separate public stateless service for running keri tasks that are not available with the rust Bridge. So it looks like that is also accurate even though maybe it could be a little more precise. But then it has the trust boundaries section and this is where it looks to be a little off. Or maybe I just don't understand it. When I first look at it it looks to me like the trust boundaries are applying to the title and there are three titles that says primary server remote Helper and the rust Bridge. Now if I compare the primary server I assume this is talking about if the software is installed and the back end is configured as the primary server, then there is full Trust because it manages the keys and everything but it's not clear why it says mobile remote mode because the software could be installed on a mobile app or it could be installed on hey Lennox OS and in either case it could be a primary server. But it doesn't necessarily have to be a mobile remote mode. The remote helper does seem to be very accurate because if we are talking about the keri remote helper then that will only ever be accessible in Mobile Standalone mode or it will only be necessary to use in that case and yes it has zero trust and everything the relationship data access constraint and operations appear to all be accurate there. For the rust Bridge it says mobile Standalone mode but to me the only time you will use the rust bridge is on a mobile device and it will be either in Mobile Standalone or mobile remote mode. So I'm not exactly sure still what primary server means and refers to. The only thing I can think of is that this is trying to say that the keri remote helper service if that's what it's referring to and then the rust Bridge refers to the keri rust Bridge so both of those are keri libraries or they are means to access the keri Library. And then where it says primary server which is the first section listed under the trust boundaries title, I believe that is referring to the child driver that runs in the python child process of keri. So when so this child process will only ever be used on the Linux and Mac OS and windows and Etc platforms where python is allowed to run. And in terms of the modes, if a desktop application well let me put it this way if flutter is running on a Linux and it needs access to akeri Library then it can just access the child keri driver process. And that's it so it doesn't matter if it's desktop mode or web mobile, if the front end flutter application running on a Linux Mac OS windows needs access to the keri Library, then it uses the child driver process. That's it. So I think even explaining the three modes where the first mode is described as desktop mode, I think that's confusing because there is no official desktop mode but rather it is simply determined by whether the flutter application needs access to the keri library then it will simply use the child driver. So we need to clarify what the different modes are as well I think but all of this again I think has to do with the keri infrastructure so we're only talking about keri operating modes. And I don't think there's such a thing as akeri operating mode it's just found in or hosted or let's put it this way the keri library is made available in three locations. The first and most widely and most commonly used one will be the child driver process that runs on a Linux Mac OS or Windows. The second available library is on is made for the operating systems of IOS and Android which is the flutter rust Bridge. And then the third source of the library, due to the lack of all features being available in the rust flutter Bridge, the remaining 10% of functions are made available via a public remote helper service. So it comes down to this. There are only two locations where you can access all keri Library features. The first location is the child driver that only runs on Linux Mac OS and windows. The second location is comprised of two sources simply because of the lack of availability of a comprehensive Source. If it's located on the flutter rust Bridge as well as the helper remote helper micro service. Both of those two complement each other because together they provide all functionality to its counterpart the python-based child driver process that only runs on Linux Mac OS and windows. Does this help clarify everything? Will you please confirm how you understand all of this and share it with me to proposed changes? Thanks!